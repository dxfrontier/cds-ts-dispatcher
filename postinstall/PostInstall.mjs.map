{"version":3,"sources":["util/EnvGenerator.ts","util/FileManager.ts","util/ShellCommander.ts","PostInstall.ts"],"sourcesContent":["import { writeFileSync } from 'fs';\nimport { json2ts } from 'json-ts';\n\nimport { FileManager } from './FileManager';\nimport { ShellCommander } from './ShellCommander';\n\nexport class EnvGenerator {\n  private readonly fileManager = new FileManager();\n  private readonly shellCommander = new ShellCommander();\n\n  private generateTypeDefinitions(jsonString: string): string {\n    return json2ts(jsonString, { rootName: 'CDS_ENV', prefix: '' });\n  }\n\n  private getCdsEnvOutput(path: string): string {\n    return this.shellCommander.executeCommand('cds', ['env', 'get'], path);\n  }\n\n  private createEnvFile(filePath: string, envConfig: string): void {\n    const typeDefinitions = this.generateTypeDefinitions(envConfig);\n    const fileContent = `// Type definitions for envConfig\\nexport ${typeDefinitions}`;\n\n    writeFileSync(filePath, fileContent);\n  }\n\n  private compileEnvFile(envFilePath: string, dispatcherPath: string): void {\n    this.shellCommander.compileEnvFile(envFilePath, dispatcherPath);\n  }\n\n  private generateEnvFiles(): void {\n    this.fileManager.dispatcherExecutionPath.paths.forEach(({ executedInstalledPath, envFilePath, dispatcherPath }) => {\n      const output = this.getCdsEnvOutput(executedInstalledPath);\n\n      this.createEnvFile(envFilePath, output);\n      this.compileEnvFile(envFilePath, dispatcherPath);\n    });\n  }\n\n  public run(): void {\n    try {\n      this.generateEnvFiles();\n    } catch (error) {\n      console.error('Error generating environment files:', error);\n      process.exit(1);\n    }\n  }\n}\n","import path from 'path';\nimport { existsSync, appendFileSync, writeFileSync, mkdirSync, readFileSync } from 'fs';\n\nimport { parse as parseJsonc, ParseError } from 'jsonc-parser';\nimport { ExecutionPaths, PackageJson } from './types';\n\nexport class FileManager {\n  private readonly currentInstallDirectory = process.env.INIT_CWD!;\n  private readonly dispatcherNecessaryFiles = {\n    packageJson: 'package.json',\n    folder: '@dispatcher',\n    env: 'index.ts',\n    gitIgnore: '.gitignore',\n    tsConfig: 'tsconfig.json',\n  };\n\n  public readonly dispatcherExecutionPath: {\n    paths: ExecutionPaths;\n  } = { paths: [] };\n\n  constructor() {\n    this.run();\n  }\n\n  public static joinPaths(...paths: string[]) {\n    return path.join(...paths);\n  }\n\n  private getPackageJson() {\n    const parsedPackage: PackageJson = this.getParsedPackageJson();\n\n    return {\n      hasWorkspaces: (): boolean => (parsedPackage.workspaces?.length ?? 0) > 0,\n      getWorkspaces: (): string[] => parsedPackage.workspaces!,\n    };\n  }\n\n  private getParsedPackageJson(workspace?: string): PackageJson {\n    let packageJsonPath: string;\n\n    if (!workspace) {\n      // Case 1: when it's a root\n      packageJsonPath = this.joinPaths(this.currentInstallDirectory, this.dispatcherNecessaryFiles.packageJson);\n    } else if (path.isAbsolute(workspace)) {\n      // Case 3: when workspace is a full path\n      packageJsonPath = workspace;\n    } else {\n      // Case 2: when it's a workspace but just ./workspace/name/\n      packageJsonPath = this.joinPaths(\n        this.currentInstallDirectory,\n        workspace,\n        this.dispatcherNecessaryFiles.packageJson,\n      );\n    }\n\n    return JSON.parse(readFileSync(packageJsonPath, 'utf8'));\n  }\n\n  private createFolderIfAbsent(folderPath: string) {\n    if (!existsSync(folderPath)) {\n      mkdirSync(folderPath, { recursive: true });\n    }\n  }\n\n  private createFileIfAbsent(filePath: string, defaultContent = '') {\n    if (!existsSync(filePath)) {\n      writeFileSync(filePath, defaultContent);\n    }\n  }\n\n  private joinPaths(...paths: string[]) {\n    return path.join(...paths);\n  }\n\n  private isDispatcherFound(dependencies: Record<string, string>): boolean {\n    return dependencies && dependencies['@dxfrontier/cds-ts-dispatcher'] !== undefined;\n  }\n\n  private appendLineIfAbsent(filePath: string, line: string) {\n    const content = readFileSync(filePath, 'utf8');\n    if (!content.includes(line)) {\n      appendFileSync(filePath, `\\n${line}\\n`);\n    }\n  }\n\n  private updateGitIgnore(filePath: string) {\n    this.appendLineIfAbsent(filePath, this.dispatcherNecessaryFiles.folder);\n  }\n\n  private updatePackageJsonImports(filePath: string) {\n    if (existsSync(filePath)) {\n      const packageJson = this.getParsedPackageJson(filePath);\n\n      packageJson.imports = packageJson.imports || {};\n\n      if (!packageJson.imports['#dispatcher']) {\n        packageJson.imports['#dispatcher'] = './@dispatcher/index.js';\n        writeFileSync(filePath, JSON.stringify(packageJson, null, 2));\n      }\n    }\n  }\n\n  private updateTsconfigInclude(filePath: string) {\n    if (existsSync(filePath)) {\n      const tsconfigContent = readFileSync(filePath, 'utf8');\n      const errors: ParseError[] = [];\n\n      const tsconfig = parseJsonc(tsconfigContent, errors);\n\n      if (errors.length > 0) {\n        throw new Error('tsconfig.json contains comments or invalid JSON format !');\n      }\n\n      tsconfig.include = tsconfig.include || [];\n\n      if (!tsconfig.include.includes('./@dispatcher')) {\n        tsconfig.include.push('./@dispatcher');\n        writeFileSync(filePath, JSON.stringify(tsconfig, null, 2));\n      }\n    }\n  }\n\n  private createOrUpdateConfigFiles(options: {\n    envFilePath: string;\n    gitignoreFilePath: string;\n    packageJsonPath: string;\n    tsconfigPath: string;\n    dispatcherFolderPath: string;\n  }) {\n    // Folder\n    this.createFolderIfAbsent(options.dispatcherFolderPath);\n\n    // Files\n    this.createFileIfAbsent(options.envFilePath);\n    this.createFileIfAbsent(options.gitignoreFilePath);\n\n    // Configs\n    this.updateGitIgnore(options.gitignoreFilePath);\n    this.updatePackageJsonImports(options.packageJsonPath);\n    this.updateTsconfigInclude(options.tsconfigPath);\n  }\n\n  private processWorkspace(workspace: string) {\n    const workspacePath = this.joinPaths(this.currentInstallDirectory, workspace);\n    this.processInstallation(workspacePath);\n  }\n\n  private processInstallation(targetDirectory: string) {\n    const dispatcherFolderPath = this.joinPaths(targetDirectory, this.dispatcherNecessaryFiles.folder);\n    const packageJsonPath = this.joinPaths(targetDirectory, this.dispatcherNecessaryFiles.packageJson);\n    const tsconfigPath = this.joinPaths(targetDirectory, this.dispatcherNecessaryFiles.tsConfig);\n    const gitignoreFilePath = this.joinPaths(targetDirectory, this.dispatcherNecessaryFiles.gitIgnore);\n    const envFilePath = this.joinPaths(dispatcherFolderPath, this.dispatcherNecessaryFiles.env);\n\n    this.createOrUpdateConfigFiles({\n      dispatcherFolderPath,\n      envFilePath,\n      gitignoreFilePath,\n      packageJsonPath,\n      tsconfigPath,\n    });\n\n    this.dispatcherExecutionPath.paths.push({\n      executedInstalledPath: targetDirectory,\n      envFilePath,\n      dispatcherPath: dispatcherFolderPath,\n    });\n  }\n\n  private processRoot() {\n    this.processInstallation(this.currentInstallDirectory);\n  }\n\n  private processWorkspaces() {\n    this.getPackageJson()\n      .getWorkspaces()\n      .forEach((workspace) => {\n        const packageJson: PackageJson = this.getParsedPackageJson(workspace);\n\n        if (this.isDispatcherFound(packageJson.dependencies)) {\n          this.processWorkspace(workspace);\n        }\n\n        if (this.isDispatcherFound(packageJson.devDependencies)) {\n          throw new Error('CDS-TS-Dispatcher should be installed in `dependencies` not in `devDependencies`!');\n        }\n      });\n  }\n\n  private run(): void {\n    if (this.getPackageJson().hasWorkspaces()) {\n      this.processWorkspaces();\n      return;\n    }\n\n    this.processRoot();\n  }\n}\n","import { sync } from 'cross-spawn';\n\nexport class ShellCommander {\n  constructor() {}\n\n  public executeCommand(command: string, args: string[], currentExecutionPath?: string) {\n    const result = sync(command, args, { encoding: 'utf8', cwd: currentExecutionPath });\n\n    if (result.error && result.stderr) {\n      throw new Error(result.stderr);\n    }\n\n    return result.stdout;\n  }\n\n  compileEnvFile(envFilePath: string, dispatcherFolderPath: string) {\n    this.executeCommand('npx tsc', [envFilePath, '--outDir', dispatcherFolderPath]);\n  }\n}\n","import { EnvGenerator } from './util/EnvGenerator';\n\nclass PostInstall {\n  private readonly GenerateEnv: EnvGenerator;\n\n  public run() {\n    new EnvGenerator().run();\n    // add more postinstall utils if needed ...\n  }\n}\n\nnew PostInstall().run();\n"],"mappings":"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","names":["writeFileSync","json2ts","path","existsSync","appendFileSync","writeFileSync","mkdirSync","readFileSync","parse","parseJsonc","FileManager","currentInstallDirectory","process","env","INIT_CWD","dispatcherNecessaryFiles","packageJson","folder","gitIgnore","tsConfig","dispatcherExecutionPath","paths","constructor","run","joinPaths","path","join","getPackageJson","parsedPackage","getParsedPackageJson","hasWorkspaces","workspaces","length","getWorkspaces","workspace","packageJsonPath","isAbsolute","JSON","parse","readFileSync","createFolderIfAbsent","folderPath","existsSync","mkdirSync","recursive","createFileIfAbsent","filePath","defaultContent","writeFileSync","isDispatcherFound","dependencies","undefined","appendLineIfAbsent","line","content","includes","appendFileSync","updateGitIgnore","updatePackageJsonImports","imports","stringify","updateTsconfigInclude","tsconfigContent","errors","tsconfig","parseJsonc","Error","include","push","createOrUpdateConfigFiles","options","dispatcherFolderPath","envFilePath","gitignoreFilePath","tsconfigPath","processWorkspace","workspacePath","processInstallation","targetDirectory","executedInstalledPath","dispatcherPath","processRoot","processWorkspaces","forEach","devDependencies","sync","ShellCommander","constructor","executeCommand","command","args","currentExecutionPath","result","sync","encoding","cwd","error","stderr","Error","stdout","compileEnvFile","envFilePath","dispatcherFolderPath","EnvGenerator","fileManager","FileManager","shellCommander","ShellCommander","generateTypeDefinitions","jsonString","json2ts","rootName","prefix","getCdsEnvOutput","path","executeCommand","createEnvFile","filePath","envConfig","typeDefinitions","fileContent","writeFileSync","compileEnvFile","envFilePath","dispatcherPath","generateEnvFiles","dispatcherExecutionPath","paths","forEach","executedInstalledPath","output","run","error","console","process","exit","PostInstall","GenerateEnv","run","EnvGenerator"]}