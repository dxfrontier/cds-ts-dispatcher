{"version":3,"sources":["util/EnvGenerator.ts","util/FileManager.ts","util/ShellCommander.ts","PostInstall.ts"],"sourcesContent":["import { writeFileSync } from 'fs';\nimport { json2ts } from 'json-ts';\n\nimport { FileManager } from './FileManager';\nimport { ShellCommander } from './ShellCommander';\n\nexport class EnvGenerator {\n  private readonly fileManager = new FileManager();\n  private readonly shellCommander = new ShellCommander();\n\n  private generateTypeDefinitions(jsonString: string): string {\n    return json2ts(jsonString, { rootName: 'CDS_ENV', prefix: '' });\n  }\n\n  private getCdsEnvOutput(path: string): string {\n    return this.shellCommander.executeCommand('cds', ['env', 'get'], path);\n  }\n\n  private createEnvFile(filePath: string, envConfig: string): void {\n    const typeDefinitions = this.generateTypeDefinitions(envConfig);\n    const fileContent = `// Type definitions for envConfig\\nexport ${typeDefinitions}`;\n\n    writeFileSync(filePath, fileContent);\n  }\n\n  private compileEnvFile(envFilePath: string, dispatcherPath: string): void {\n    this.shellCommander.compileEnvFile(envFilePath, dispatcherPath);\n  }\n\n  private generateEnvFiles(): void {\n    this.fileManager.dispatcherExecutionPath.paths.forEach(({ executedInstalledPath, envFilePath, dispatcherPath }) => {\n      const output = this.getCdsEnvOutput(executedInstalledPath);\n\n      this.createEnvFile(envFilePath, output);\n      this.compileEnvFile(envFilePath, dispatcherPath);\n    });\n  }\n\n  public run(): void {\n    try {\n      this.generateEnvFiles();\n    } catch (error) {\n      console.error('Error generating environment files:', error);\n      process.exit(1);\n    }\n  }\n}\n","import path from 'path';\nimport { existsSync, appendFileSync, writeFileSync, mkdirSync, readFileSync } from 'fs';\n\nimport { parse as parseJsonc, ParseError } from 'jsonc-parser';\nimport { ExecutionPaths, PackageJson } from './types';\n\nimport fg from 'fast-glob';\nexport class FileManager {\n  private readonly currentInstallDirectory = process.env.INIT_CWD!;\n  private readonly dispatcherNecessaryFiles = {\n    packageJson: 'package.json',\n    folder: '@dispatcher',\n    env: 'index.ts',\n    gitIgnore: '.gitignore',\n    tsConfig: 'tsconfig.json',\n  };\n\n  public readonly dispatcherExecutionPath: {\n    paths: ExecutionPaths;\n  } = { paths: [] };\n\n  constructor() {\n    this.run();\n  }\n\n  public static joinPaths(...paths: string[]) {\n    return path.join(...paths);\n  }\n\n  private readPackageJson(filePath: string): PackageJson {\n    return JSON.parse(readFileSync(filePath, 'utf8'));\n  }\n\n  private getRootPackageJson() {\n    const path = FileManager.joinPaths(this.currentInstallDirectory, this.dispatcherNecessaryFiles.packageJson);\n    const packageJson: PackageJson = this.readPackageJson(path);\n\n    return {\n      hasWorkspaces: (): boolean => (packageJson.workspaces?.length ?? 0) > 0,\n      getWorkspaces: (): string[] => packageJson.workspaces!,\n    };\n  }\n\n  private isWorkspaceDynamicPattern(workspace: string): boolean {\n    return fg.isDynamicPattern(workspace) ? true : false;\n  }\n\n  private getParsedPackageJson(workspace: string) {\n    // path join has an issue with '*' and I am replacing it with empty '' and adding later when is needed\n    const sanitizedWorkspace = workspace.replace('*', '');\n    const path = FileManager.joinPaths(this.currentInstallDirectory, sanitizedWorkspace);\n\n    /**\n     * When the package.json is on the root level, meaning it doesn't have workspaces\n     */\n    const resolveRoot = (): string => {\n      return FileManager.joinPaths(this.currentInstallDirectory, this.dispatcherNecessaryFiles.packageJson);\n    };\n\n    /**\n     * When the package.json has workspaces with the '*'\n     * @example\n     * \"workspaces\": [\n     *   \"./services/*\"\n     * ]\n     */\n    const resolveDynamicPattern = (): PackageJson[] => {\n      const workspaces = fg.globSync(`${path}*/${this.dispatcherNecessaryFiles.packageJson}`, { dot: true });\n      const jsons: PackageJson[] = [];\n\n      workspaces.forEach((item, index) => {\n        const fields: PackageJson = {\n          path: item.replace('package.json', ''),\n          ...JSON.parse(readFileSync(workspaces[index], 'utf8')),\n        };\n\n        jsons.push(fields);\n      });\n\n      return jsons;\n    };\n\n    /**\n     * When the package.json has workspaces with the '*'\n     * @example\n     * \"workspaces\": [\n     *   \"./services/admin\",\n     *   \"./services/api\"\n     * ]\n     */\n    const resolveStaticWorkspaces = (): PackageJson[] => {\n      const fields: PackageJson = {\n        path,\n        ...JSON.parse(readFileSync(FileManager.joinPaths(path, this.dispatcherNecessaryFiles.packageJson), 'utf8')),\n      };\n\n      return [fields];\n    };\n\n    return {\n      resolveDynamicPattern,\n      resolveStaticWorkspaces,\n      resolveRoot,\n    };\n  }\n\n  private createFolderIfAbsent(folderPath: string) {\n    if (!existsSync(folderPath)) {\n      mkdirSync(folderPath, { recursive: true });\n    }\n  }\n\n  private createFileIfAbsent(filePath: string, defaultContent = '') {\n    if (!existsSync(filePath)) {\n      writeFileSync(filePath, defaultContent);\n    }\n  }\n\n  private validateDispatcherDependency(dependencies: Record<string, string>): boolean {\n    return dependencies && dependencies['@dxfrontier/cds-ts-dispatcher'] !== undefined;\n  }\n\n  private appendLineIfAbsent(filePath: string, line: string) {\n    const content = readFileSync(filePath, 'utf8');\n    if (!content.includes(line)) {\n      appendFileSync(filePath, `\\n${line}\\n`);\n    }\n  }\n\n  private updateGitIgnore(filePath: string) {\n    this.appendLineIfAbsent(filePath, this.dispatcherNecessaryFiles.folder);\n  }\n\n  private updatePackageJsonImports(filePath: string) {\n    if (existsSync(filePath)) {\n      const json: PackageJson = JSON.parse(readFileSync(filePath, 'utf8'));\n\n      json.imports = json.imports || {};\n\n      if (!json.imports['#dispatcher']) {\n        json.imports['#dispatcher'] = './@dispatcher/index.js';\n        writeFileSync(filePath, JSON.stringify(json, null, 2));\n      }\n    }\n  }\n\n  private updateTsconfigInclude(filePath: string) {\n    if (existsSync(filePath)) {\n      const tsconfigContent = readFileSync(filePath, 'utf8');\n      const errors: ParseError[] = [];\n\n      const tsconfig = parseJsonc(tsconfigContent, errors);\n\n      if (errors.length > 0) {\n        throw new Error('tsconfig.json contains comments or invalid JSON format !');\n      }\n\n      tsconfig.include = tsconfig.include || [];\n\n      if (!tsconfig.include.includes('./@dispatcher')) {\n        tsconfig.include.push('./@dispatcher');\n        writeFileSync(filePath, JSON.stringify(tsconfig, null, 2));\n      }\n    }\n  }\n\n  private createOrUpdateConfigFiles(options: {\n    envFilePath: string;\n    gitignoreFilePath: string;\n    packageJsonPath: string;\n    tsconfigPath: string;\n    dispatcherFolderPath: string;\n  }) {\n    // Folder\n    this.createFolderIfAbsent(options.dispatcherFolderPath);\n\n    // Files\n    this.createFileIfAbsent(options.envFilePath);\n    this.createFileIfAbsent(options.gitignoreFilePath);\n\n    // Configs\n    this.updateGitIgnore(options.gitignoreFilePath);\n    this.updatePackageJsonImports(options.packageJsonPath);\n    this.updateTsconfigInclude(options.tsconfigPath);\n  }\n\n  private processInstallation(directory: string) {\n    const dispatcherFolderPath = FileManager.joinPaths(directory, this.dispatcherNecessaryFiles.folder);\n    const packageJsonPath = FileManager.joinPaths(directory, this.dispatcherNecessaryFiles.packageJson);\n    const tsconfigPath = FileManager.joinPaths(directory, this.dispatcherNecessaryFiles.tsConfig);\n    const gitignoreFilePath = FileManager.joinPaths(directory, this.dispatcherNecessaryFiles.gitIgnore);\n    const envFilePath = FileManager.joinPaths(dispatcherFolderPath, this.dispatcherNecessaryFiles.env);\n\n    this.createOrUpdateConfigFiles({\n      dispatcherFolderPath,\n      envFilePath,\n      gitignoreFilePath,\n      packageJsonPath,\n      tsconfigPath,\n    });\n\n    this.dispatcherExecutionPath.paths.push({\n      executedInstalledPath: directory,\n      envFilePath,\n      dispatcherPath: dispatcherFolderPath,\n    });\n  }\n\n  private processRoot() {\n    this.processInstallation(this.currentInstallDirectory);\n  }\n\n  private processWorkspaces() {\n    const workspaces = this.getRootPackageJson().getWorkspaces();\n\n    workspaces.forEach((workspace) => {\n      const isDynamic = this.isWorkspaceDynamicPattern(workspace);\n      const packages = isDynamic\n        ? this.getParsedPackageJson(workspace).resolveDynamicPattern()\n        : this.getParsedPackageJson(workspace).resolveStaticWorkspaces();\n\n      packages.forEach((pkg) => {\n        if (this.validateDispatcherDependency(pkg.dependencies)) {\n          isDynamic\n            ? this.processInstallation(pkg.path)\n            : this.processInstallation(FileManager.joinPaths(this.currentInstallDirectory, workspace));\n        }\n      });\n    });\n  }\n\n  private run(): void {\n    if (this.getRootPackageJson().hasWorkspaces()) {\n      this.processWorkspaces();\n      return;\n    }\n\n    this.processRoot();\n  }\n}\n","import { sync } from 'cross-spawn';\n\nexport class ShellCommander {\n  constructor() {}\n\n  public executeCommand(command: string, args: string[], currentExecutionPath?: string) {\n    const result = sync(command, args, { encoding: 'utf8', cwd: currentExecutionPath });\n\n    if (result.error && result.stderr) {\n      throw new Error(result.stderr);\n    }\n\n    return result.stdout;\n  }\n\n  compileEnvFile(envFilePath: string, dispatcherFolderPath: string) {\n    this.executeCommand('npx tsc', [envFilePath, '--outDir', dispatcherFolderPath]);\n  }\n}\n","import { EnvGenerator } from './util/EnvGenerator';\n\nclass PostInstall {\n  private readonly GenerateEnv: EnvGenerator;\n\n  public run() {\n    new EnvGenerator().run();\n    // add more postinstall utils if needed ...\n  }\n}\n\nnew PostInstall().run();\n"],"mappings":"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","names":["writeFileSync","json2ts","path","existsSync","appendFileSync","writeFileSync","mkdirSync","readFileSync","parse","parseJsonc","fg","FileManager","currentInstallDirectory","process","env","INIT_CWD","dispatcherNecessaryFiles","packageJson","folder","gitIgnore","tsConfig","dispatcherExecutionPath","paths","constructor","run","joinPaths","path","join","readPackageJson","filePath","JSON","parse","readFileSync","getRootPackageJson","hasWorkspaces","workspaces","length","getWorkspaces","isWorkspaceDynamicPattern","workspace","fg","isDynamicPattern","getParsedPackageJson","sanitizedWorkspace","replace","resolveRoot","resolveDynamicPattern","globSync","dot","jsons","forEach","item","index","fields","push","resolveStaticWorkspaces","createFolderIfAbsent","folderPath","existsSync","mkdirSync","recursive","createFileIfAbsent","defaultContent","writeFileSync","validateDispatcherDependency","dependencies","undefined","appendLineIfAbsent","line","content","includes","appendFileSync","updateGitIgnore","updatePackageJsonImports","json","imports","stringify","updateTsconfigInclude","tsconfigContent","errors","tsconfig","parseJsonc","Error","include","createOrUpdateConfigFiles","options","dispatcherFolderPath","envFilePath","gitignoreFilePath","packageJsonPath","tsconfigPath","processInstallation","directory","executedInstalledPath","dispatcherPath","processRoot","processWorkspaces","isDynamic","packages","pkg","sync","ShellCommander","constructor","executeCommand","command","args","currentExecutionPath","result","sync","encoding","cwd","error","stderr","Error","stdout","compileEnvFile","envFilePath","dispatcherFolderPath","EnvGenerator","fileManager","FileManager","shellCommander","ShellCommander","generateTypeDefinitions","jsonString","json2ts","rootName","prefix","getCdsEnvOutput","path","executeCommand","createEnvFile","filePath","envConfig","typeDefinitions","fileContent","writeFileSync","compileEnvFile","envFilePath","dispatcherPath","generateEnvFiles","dispatcherExecutionPath","paths","forEach","executedInstalledPath","output","run","error","console","process","exit","PostInstall","GenerateEnv","run","EnvGenerator"]}